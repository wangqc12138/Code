构造函数可以是虚函数吗？
    构造对象的时候，必须知道对象的实际类型。而虚函数行为是在运行期间确定实际类型的，在构造对象的时，对象还没有构造成功，编译器无法知道对象的实际类型是该类本身还是其派生类。
    虚函数的运行依赖于虚函数指针，而虚函数指针在构造函数中进程初始化，让它指向正确的虚函数表，而在对象构造期间，虚函数指针还未构造完成。
c++虚函数原理
    虚函数是依赖于虚函数指针实现，每个拥有虚函数的类都有一个虚表，类的对象存在一个虚函数指针，指向实际类型的虚表。虚函数运行的时候，会根据虚函数指针找到正确的虚表，从而执行正确的虚函数。
c++多态的实现
    多态分为两种，一种是运行时的多态，一种是编译时的多态。前者称为动态绑定，后者称为静态绑定。动态绑定时由虚函数来实现，静态绑定是由函数重载来实现。
c++ vector和list的区别？
    vector是动态数组，会动态进行分配内存，进行扩容操作。list是双向链表。
访问vector的迭代器的时候可以删减元素吗？list呢
    任何对vector的修改都将导致vector的迭代器失效。list因为是双向链表，所以不会失效。
c++ vector的底层实现原理
    vector底层是基于动态数组实现。
c++ map的底层实现
    map的底层实现是基于红黑树的。
红黑树的特点以及常见的二叉平衡树
    红黑树性能比较高，插入删除时间复杂度保持在logn。和AVL相比，要求不是那么严格，它只要求到叶节点的最长路径不超过最短路径的两倍。
    相比之下，AVL要求左右子树相差高度不超过一，简单的插入或者删除都会导致树的不平衡需要旋转操作。
c++空类的sizeof大小
    c++空类的大小为1，如果含有虚函数的话，大小为指针的大小。32位系统指针大小是4。c++要求即使是空类，对象也要有存储空间。含有虚函数的空类则是因为对象由虚函数指针。
解释线程安全和可重入函数
    一个可重入函数被称为可重入的，表明该函数被重入之后，不会产生任何不良后果，一个函数被重入，表示这个函数没有执行完成，由于内部原因或外部原因调用，又一次进入该函数执行
构造函数调用虚函数可不可以
    不可以。说了下虚函数的作用以及构造函数的调用顺序。
    后面又问，如果调用会出现啥情况。因为不确定所以说不知道。回来测试了下，是调用被调对象的自己的版本。
static关键字作用
    局部变量 静态存储区 初始化一次 生命周期程序 作用域局部函数内
    全局变量 静态存储区
    函数 在文件中可见，文件外不可见
    成员变量 所有对象都只维持一份拷贝，不需要实例化，不能类内部初始化
    成员函数 不接受this指针，只能访问静态成员，不需要实例化对象就能访问
define和const
    define宏是预处理阶段展开，不能调试 const是编译阶段使用
    define不做类型检查，只是代码展开 const编译阶段检查
    define做字符串替换，不分配内存，代码段 const分配内存一份 数据段
    define不受定义域限制，const定义域内有效
inline
    对比函数调用 节省调用时间 怎么节省？普通调用使用函数栈
    对比宏函数 会进行语法安全检查
    用不用是编译器说了算 如果代码段太复杂 则按函数调用使用
智能指针
    RAII 动态分配内存 封装类对象指针，在离开作用域时调用析构函数使用delete删除内存空间
    auto_ptr 独占式拥有 在c++11中被摒弃
        对象所有权的转移，比如在函数传参过程中，对象所有权不会返还
        不能指向数组 也不能作为STL容器的对象
    unique_ptr 同一时间只能有一个智能指针指向该对象 无拷贝构造和拷贝赋值 有移动构造和移动赋值
    shared_ptr 共享式拥有
    weak_ptr 解决shared_ptr相互引用时，两个指针的引用计数永远不会下降为0，从而死锁
    对对象的弱引用，可以绑定到shared_ptr上，不会增加对象的引用计数
shared_ptr实现
    构造函数计数初始化为1
    拷贝构造函数中计数值加1
    赋值运算符中 左边对象减一 右边对象加1
    析构中减一
    如果为0则delete释放
右值引用
    转移语义 完美转发
    消除两个对象交互时不必要的对象拷贝 更加简洁明确地定义泛型函数
悬挂指针和野指针
    悬挂指针 当指针所指向地对象被释放，但是指针没有变化仍指向已被收回内存地地址
    野指针 未初始化地指针
静态链接和动态链接
    静态链接在编译时直接把需要地执行代码拷贝到调用处
    优点程序发布时不依赖库，可以独立执行，缺点程序体积大，更新会导致所有可执行文件重新编译
    动态链接编译时不直接拷贝代码，通过记录一系列符号和参数，在程序运行/加载时传递这些信息
    操作系统将需要地库加载到内存中，然后程序在运行时去共享执行内存中找可执行代码
    优点多个程序共享一个动态库
    缺点运行时加载可能影响执行性能
声明和定义
    声明不分配地址
sizeof和strlen
    sizeof时操作符，strlen是库函数
    sizeof参数可以是类型也可以是变量
    strlen参数是字符串
    sizeof编译时就计算好了，数据类型内存大小
    strlen运行时才计算出来
    数组sizeof不退化 strlen退化为指针
volatile
    这个变量随时会变化 不优化 直接从内存地址读取
const和volatile
    可以共用
全局和局部变量
    生存周期
    作用域
    内存存放位置
指针常量和常量指针

队列和栈

野指针
    声明时初始化
    free delete后指向null
    超出变量作用范围 提前释放
多态
    静态多态 重载和模板 编译期间确定
    动态多态 虚函数 动态绑定 运行期间确定
动态多态
    隐藏实现细节
    结构重用 向后兼容 派生类地功能可以被基类地指针/引用所调用
    继承
    虚函数覆盖
动态多态实现
    虚函数---虚函数表---虚函数指针
    派生类覆盖基类 指针会替换 从而动态绑定
纯虚函数
    =0
虚函数表
    针对类地，类地所有对象共享这个类地虚函数表
    每个对象都有虚函数指针
构造函数可以是虚函数吗？
    不可以，虚函数的调用依赖虚函数表，vptr需要在构造函数中初始化
基类虚析构
    动态绑定，在对象销毁时，调用派生类的数据
构造函数和析构函数可以抛出异常吗
    构造函数可以抛出，但是不建议，可能会导致内存泄漏
    析构不可以 异常抛出后，程序不会执行后续。而且抛出异常，程序调用异构，再来异常会崩溃
类不实例化
    抽象类，纯虚函数
    构造函数private 单例模式
多继承
    同名二义性--域运算符 或者重写覆盖
    路径二义性--2+虚继承
空类的sizeof大小
    1
    虚函数 指针大小
覆盖和重载
    覆盖函数体发生变化
    重载只有函数名相同
拷贝构造 拷贝赋值
    拷贝构造用于构造新的对象
    拷贝赋值用于已存在的对象
强制类型转换
    static_cast 非多态 数值数据
    dynamic_cast 多态 指针引用
hashtable
    开链法
    vector+list
vector
    动态数组 start finish已使用 end_of_storage整块连续空间的尾部
    增长机制：自动申请 然后把原来的数据拷贝过去，接着释放
    vec.clear只删除不释放
    空间重新分配会导致迭代器失效
    capacity 容器的容量 size 实际元素
    reserve capacity = n
    resize size = n
    vector底层实现要求连续的对象排列 引用并非对象，没有实际地址 所以不能放引用
    内存重新分配会导致迭代器失效
    删除元素也会导致迭代器失效
list
    双向链表
deque
    双端队列
map
    红黑树
    从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。
    mapset存储时节点不需要内容拷贝和内存移动
    插入只是结点指针换来换去，内存不变
unordered_map
    防冗余的哈希表，除留余数法 消耗较多内存
迭代器的底层机制和失效问题
    原理 萃取技术和模板偏特化
    萃取技术 
    随机迭代器 双向迭代器 前向迭代器
    迭代器失效的问题
    插入 vector string重新分配失效
容器删除
    顺序容器
    it = erase(it)
    关联容器
    erase(it++)
越界
    vector 会做边界检查
    map 存在返回 不存在新建默认值
    erase 只能删除 不能改变容量大小
STL内存优化
    二级内存配置器
    malloc free第一级分配大于128字节的空间 如果不成功释放一部分，再不成功抛出异常
    小于128字节 内存池 自由链表数组 指针数组 每个指针元素指向一个链表起始节点
    链表元素内存结点 
    如果链表为空则填充，默认为20
    从内存池分配一大块内存，默认为20歌链表节点大小 内存池不足则返回实际大小
    refill将其链接起来
    内存池 够直接分配 不够给一份 一份也不够 将拥有的分配给合适的链表，然后申请malloc
    大小为所需的2倍 成功分配，失败找其他链表要内存块 然后分配 若再没有就调用一级分配
new/delete malloc/free
    new 先申请再构造再强转
    delete 先析构再free
    delete free后需要指针指向null，防止野指针 此时内存没立即收回
delete[]依次析构
内存泄漏
    没有成对
    valgrind mtrace
类只在堆栈
    堆：析构为private
    栈：new delete private