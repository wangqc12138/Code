c++
1、智能指针
2、引用和指针的区别
    引用本质是别名 指针本质是地址
    指针可以在运行时改变 引用不能改变指向
    指针会分配内存 引用不会
    参数传递 引用会做类型检查 指针不会
    指针可以为空 引用不可以
    引用必须初始化 指针不必
3、const define 
    const参与编译运行 define字符串替换
    const占用内存 define不占用内存
    const有类型检查 define不做
    const内存效率高 编译期间的常量 不分配存储空间
4、define inline
    define字符串替换 inline编译器控制
    define只是替换 不做安全检查 inline展开函数 做安全检查
5、malloc new
    new = malloc + ctr
6、static
    可见性
    保持变量持久性
    默认初始化为0
    静态不能做虚函数
    静态类成员需要初始化 在外面
7、const static
    不可以同时修饰成员函数
8、虚函数
    虚函数表 虚函数指针 动态绑定 多态 静态的话时重载
9、析构函数是虚函数
    子类需要析构资源，如果不是虚函数，会导致内存泄漏
10、内联函数 构造函数 静态成员函数 
    都不可以是虚函数
    静态成员函数是类为单位的函数
11、构造函数调用虚函数
    没有动态绑定效果 仍是自己的函数
12、虚继承
    用于解决多继承状态下的棱形继承问题 通过虚基类指针实现 各对象只保存一份父类对象 多继承时引用该指针
13、子类析构时要调用父类的析构函数吗？
    不 父类析构时候 子类的信息都已经销毁了
14、引用
    别名 需要声明时初始化
    引用不占存储单元 不能建立数组的引用
15、重载 重写
    重载 就函数名相同
    重写 就函数体不同
16、main函数执行之前
    全局对象的构造函数
17、内存分配方式
    静态存储区 编译时就分配好 整个运行期间都有 全局变量 static变量
    栈 局部变量 函数执行期间
    堆 动态分配内存 new delete
18、类对象大小
    非静态成员变量大小影响
    内存对齐
    虚函数有虚指针
    父类部分数据成员
19、堆栈区别
    堆 动态分配的对象
    栈 函数局部变量 程序块运行时存在
20、指针传递和引用传递
    指针 本身是值传递，传递地址值，作为被调函数的局部变量处理，在栈中开辟内存存放，不影响实参变量
    引用 被调函数的形参也作为局部变量在栈中存放，但是存放的是实参变量的地址，对形参的操作会访问实参
21、实参 形参
    形参只有调用才有内存 实参必须具有确定的值
22、迭代器的实现
    类模板 仿指针
23、野指针
    指向内存被释放（悬挂指针） 指向没有访问权限
    没初始化
    free没置null
    指针超出作用范围
24、