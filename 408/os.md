# **概述**
- 操作系统基本概念
- 操作系统发展历程
- 程序运行环境
	- CPU运行模式
		- 内核模式、用户模式
	- 中断和异常的处理
	- 系统调用
	- 程序的链接和装入
	- 程序运行时内存印象与地址空间
- 操作系统结构
	- 分层、模块化、宏内核、微内核、外核
- 操作系统引导
- 虚拟机
# **进程管理**
- 进程与线程
	- 进程与线程的基本概念
		- 进程
			- 进程概念
				> 指令序列
			- 程序概念
				> 
			- 进程的组成
				> 程序段、数据段、PCB
				> PCB是进程存在的唯一标志
				- PCB的构成
					> 进程描述信息（PID、UID）
					> 进程控制和管理信息（进程当前状态、进程优先级）
					> 资源分配清单（程序段指针、数据段指针）
					> 处理机信息（寄存器内容）
			- 进程的特征
				> 动态性（最基本的特征）
				> 并发性
				> 独立性（资源分配的基本单位）
				> 异步性
				> 结构性
		- 线程
			- 线程概念
				> 轻量级进程
			- 线程属性
				> 线程是处理机调度单位（内核级线程）、进程是资源分配单位
	- 进程状态及其转换
		- 进程的状态
			- 就绪
				> 有其他资源、无CPU
			- 运行
				> 有其他资源、有CPU
				> 单核处理器每个时刻最多一个进程
			- 阻塞
				> 无其他资源、无CPU
				> 其他资源如等待分配打印机，或是等待读磁盘操作
			- 创建
				> 创建初始化PCB
			- 终止
				> 程序结束，或者BUG，撤销PCB
		- 状态转换
			- 就绪->运行
				> 进程被调到，CPU空闲
			- 运行->就绪
				> 进程CPU时间轮片到了，或者被其他高优先级进程抢占
			- 运行->阻塞
				> 缺少其他资源，如IO；或者等待某事发生（主动）
			- 阻塞->就绪
				> 资源到位，或者等待的事件发生（被动）
	- 线程的实现
		- 内核支持的线程
			> 管理工作由内核完成
			> 线程切换需要核心态
			> 从内核看到地线程
		- 线程库支持的线程
			> 线程切换在用户态下可完成
			> 对用户不透明，对操作系统透明
			> 用户视角能看到的线程
		- 多线程模型
			- 多对一	
				> 优点：线程切换在用户态下就可以完成，不需要切换到核心态，系统开销少，效率高
				> 缺点：当一个用户级线程被阻塞，整个进程被阻塞。多线程不可并发
			- 一对一
				> 当一个线程被阻塞，别的线程还能执行；可并发
				> 进程开销大
			- 多对多
				> n-m;n>=m;折中
	- 进程与线程的组织与控制
		- 进程组织
			- 链接方式
				> 按照进程状态将PCB分为多个队列，os持有指向各个队列的指针
			- 索引方式
				> 使用索引表代替队列
			- 队列
				> 就绪队列、阻塞队列
		- 进程控制
			> 实现进程状态转换
			> 进程控制用原语实现
			- 原语
				> 开、关中断实现（开关中断指令只允许在核心态下执行）
				> 一气呵成、不可中断
			- 创建原语
				> 无-创建态-就绪态
				- 原语实现
					> 申请空白PCB（分配进程标识号PID）
					> 为新进程分配所需资源
					> 初始化PCB
					> 插入就绪队列
				- 引起事件
					> 用户登录
					> 作业调度（新作业放入内存）
					> 提供服务（用户请求内核）
					> 应用请求（用户创建子进程）
			- 终止
				> -终止态-无
				- 原语实现
					> 从PCB集合中找到终止进程的PCB
					> 若进程正在使用CPU，剥夺CPU，将CPU分配给其他进程
					> 终止子进程
					> 将该进程的所有资源归还给父进程或是操作系统
					> 删除PCB
				- 引起事件
					> 正常结束 
					> 异常结束（越界，io故障，非法指令）
					> 外界干预（操作系统干预、父进程终止、请求）
			- 唤醒
				> 由阻塞相关的其他进程唤醒
				> 阻塞态-就绪态
				> 与阻塞成对出现
				- 原语实现
					> 从等待队列中找到PCB
					> 将PCB从等待队列中删除，设置进程为就绪态
					> 将PCB插入就绪队列
				- 引起事件
					> 等待的事件发生了
					> 因何事阻塞，就因何事唤醒
			- 阻塞
				> 由该进程自我调用
				> 运行态-阻塞态
				> 与唤醒成对出现
				- 原语实现
					> 找到要阻塞的进程的PCB（根据PID）
					> 保护现场，将PCB状态信息设置为阻塞，暂停进程运行
					> 将PCB插入相应事件的等待队列、将处理机资源调度给其他进程
				- 引起事件
					> 需要等待分配资源
					> 需要等待其他进程完成事件
			- 切换（与阻塞的区别？）
				> 运行态-阻塞态/就绪态|就绪态-运行态
				- 原语实现
					> 将运行环境信息存入PCB
					> PCB移入相应队列（就绪、阻塞、运行）
					> 选择另一个进程执行，并更新PCB
					> 根据PCB恢复其运行环境
				- 引起事件
					> 进程时间片到
					> 更高优先级进程来到
					> 主动阻塞
					> 进程终止
	- 进程间通信
		- 共享内存
			> 互斥地访问共享内存
		- 消息传递
			> 有信箱和无信箱
			> 发送、接收原语
		- 管道
			> 半双工-一时间单向
			> 写满无法写，读空无法读
			> 写不满无法读，没读空不能写
- CPU调度与上下文切换
	- 调度的基本概念
		- 作业调度
			> 从后备队列中选择合适的作业，调入内存，并创建进程
			> 外存-内存
		- 内存调度
			> 从挂起队列中选择合适的进程，将其数据调入内存
			> 外存-内存
			> PCB不调往外存，在内存的挂起队列中
		- 进程调度
			> 从就绪队列中选择一个合适的进程为其分配处理机
			> 内存-CPU
		- 挂起态
			> 为提高资源利用率将暂不执行的进程从内存调出外存
			> 就绪挂起、阻塞挂起  
	- 调度的目标
	- 调度的实现
		- 调度器、调度程序
		- 调度的时机
			- 需要调度（引起切换原语的事件？）
				- 主动放弃
					> 正常终止
					> 发生异常终止
					> 主动阻塞（如等待IO）
				- 被动放弃
					> 进程的时间片用完
					> 更紧急的事情发生（如IO中断）
					> 更改优先级事件进入就绪队列
			- 不可调度
				> 处理中断
				> 进程在内核程序临界区
				> 原子操作（原语）
		- 调度的方式（抢占式、非抢占式）
			- 非抢占式
				> 非剥夺式；只允许进程主动放弃处理机
			- 抢占式
				> 剥夺式；立即暂停执行的进程
		- 进程切换和调度(切换原语？)
			> 对原进程的数据进行保存，对新进程的数据进行恢复
			> 切换有代价
		- 闲逛进程
		- 内核级线程和用户级线程调度
	- 性能指标
		- CPU利用率
			> 忙碌时间/总时间
		- 系统吞吐量
			> 单位时间内完成作业的数量
			> 总共完成多少道作业/总共花了多少时间
		- 周转时间
			> 作业完成时间-作业提交（到达）时间
			> 平均周转时间=各作业周转时间之和/作业数
			> 带权周转时间=作业周转时间/作业实际运行时间
		- 等待时间
			> 处于等待处理机状态时间之和
		- 响应时间
			> 提交请求到首次产生响应所用的时间
	- 典型调度算法
		> 算法思想
		> 算法规则
		> 作业/进程调度
		> 抢占、非抢占
		> 优缺点
		> 是否饥饿
		- 先来先服务
			> 类似排队
			> 队列思想，先进先出
			> 作业调度时看后备队列、进程调度时看就绪队列
			> 非抢占式
			> 优点：简单公平；缺点：对长作业有利，对短作业不利
			> 不会饥饿
		- 短作业（短线程、短进程）优先调度算法
			> 追求最短平均等待时间
			> 最短的进程、作业被服务
			> 作业调度、进程调度都可应用
			> 非抢占式、也可改为抢占式---最短剩余时间优先（SRTN）
			> 优点：最短平均等待时间、最短平均周转时间（所有进程同时到达，同时运行）；缺点：对长作业不利，可能产生饥饿
			> 会饥饿
		- 高响应比优先调度算法
			> 综合考虑等待时间和要求服务时间
			> 响应比=等待时间+服务时间/服务时间
			> 作业调度、进程调度都可应用
			> 非抢占式
			> 等待时间相同，服务时间短优先（SJF），服务时间相同，等待时间长（FCFS）
			> 不会饥饿
		- 时间片轮转调度算法（分时操作系统）
			> 公平公正每个进程都可以得到时间片
			> 按照就绪队列，每个分配一个时间片，如果未执行完，则剥夺
			> 进程调度 
			> 抢占式--时钟中断
			> 优点：公平，响应快；缺点：高频率切换有开销且不会区分紧急度
			> 不会饥饿
			> 时间片太大：退化为FCFS服务，响应时间长；时间片太小：切换频繁
		- 优先级调度算法（实时操作系统）
			> 考虑进程、作业的紧急程度
			> 调度时选择优先级高的
			> 作业、进程、IO都有
			> 抢占式---时刻注意就绪队列；非抢占式，只在完成后看就绪队列
			> 优点：灵活区分优先程度；缺点：一直来高优先级会产生饥饿
			> 会饥饿
			> 优先级分为静态和动态；静态创建进程则一直保持，动态则可修改
			> 系统>用户；前台>后台；IO>运算
		- 多级反馈队列
			> 其他调度算法的折中
			> 1、多级就绪队列优先级从高到底，时间片从小到大
			> 2、新进程到达时进入第一队列，按照FCFS服务，若在时间片用完仍未完成，则放入下个队列的队尾，若已是最低等，则是此队列
			> 3、只有K级队列空了，才会K+1分配时间片
			> 进程调度
			> 抢占式，高等队列来进程了，就会被剥夺，此时进程放回原队列的队尾
			> 优点：相对公平（FCFS），较快响应（RR），短进程较少时间（SPF），不必估计进程预计时间（防作假），灵活调整优先级（IO回到同级队列）
			> 会饥饿
		- 多级队列
	- 上下文及其切换机制
<!-- 	- 三种调度的场景及其联系对比
		- 概念
		- 作业调度
		- 内存调度
		- 进程调度
		- 联系对比
	- 调度的时机 方式 过程
		- 需要调度
			- 被动
			- 主动
		- 不允许调度
		- 调度切换的过程
		- 切换方式
			- 剥夺
			- 非剥夺
	- 评价指标
		- CPU利用率
		- 系统吞吐量
		- 周转时间
		- 等待时间
		- 响应时间
	- 调度算法
		- 先来先服务FCFS
		- 短作业优先SJF
		- 高响应比优先HRRN
		- 三种算法的对比和总结 -->
- 同步与互斥
	- 概念
		- 临界资源
			> 进入区--检测是否进入临界区，加锁
			> 临界区--访问临界资源
			> 退出区--负责解锁
			> 剩余区--其他
		- 同步
			> 直接制约关系，确定先后顺序
		- 互斥
			> 间接制约关系，有你没我
			> 互斥准则：空闲让进；忙则等待；有限等待；让权等待
	- 互斥的软件实现方法
		- 单标志
			> 两个进程在访问完临界区修改标志，允许另一进程进入；当一个进程不进入时，另一进程未得到允许，会一直等
			> 违背空闲让进
		- 双标志先检查
			> 设置一个数组，每个元素代表这个进程想进入临界区的意愿
			> 检查和上锁不是原子性的，可能存在切换
			> 违背忙则等待
		- 双标志后检查
			> 先上锁后检查
			> 同样不是原子性，可能切换
			> 违背空闲让进和有限等待，产生饥饿现象
		- peterson
			> 在后检查的基础上增加个turn变量表示优先想让哪个进程进入临界区
			> 违反让权等待（未进入时会一直循环）
	- 互斥的硬件实现方法
		- 中断隐藏方法
			> 使用开关中断实现
			> 优点：简单高效；缺点：不适用多处理机，只适用内核，不适用用户进程
		- TestAndSet指令
			> 检查和上锁时原子性
			> 违反让权等待（不允许进入，会一直循环）
		- Swap指令
			> 同上
	- 锁
	- 信号量机制
		- 整型
		- 记录型
	- 条件变量
	- 实现
		- 互斥
		- 同步
		- 前驱
	- 经典问题
		- 生产消费
		- 读写者
		- 哲学家进餐
		- 吸烟者
- 死锁
	- 概念
	- 死锁的预防
	- 死锁的避免
		<!-- - 银行家算法 -->
	- 死锁的检测和解除
---
# **内存**
- 内存管理的基本概念
	- 程序执行过程
		- 逻辑地址物理地址
		- 编译、链接、装入
		- 装入的三种方式
		- 链接的三种方式
	- 地址变换
		- 三种方式
	- 内存共享
	- 内存保护
		- 上下限寄存器
		- 重定位寄存器，接地址寄存器
	- 内存分配与回收
		- 连续分配
			- 单一
			- 固定
			- 动态
		- 非连续分配
		- 内部碎片与外部碎片
	- 内存扩充
		- 覆盖
		- 交换
- 连续分配管理方式
- 动态分区分配
	- 首次适应算法
	- 最佳适应算法
	- 最坏（大）适应算法
	- 临近适应算法
	- 四种算法归纳比较
- 页式存储
	- 概念
	- 页号 页内偏移量的计算
	- 页表
	- 基本地址转换
	- 快表
		- 基本地址变换与快表地址变换的比较
	- 二级页表
		- 原理
		- 地址变换
- 段式存储
	- 概念
	- 段表
	- 地址变换
	- 分段、分页管理的对比
- 段页式存储
	- 分页、分段的优缺点分析
	- 分段+分页=段页式管理
    	- 段页式管理的逻辑地址结构
    	- 段页式存储的段表、页表
	- 段页式管理的地址转换过程
- 虚拟内存管理
	- 基本概念
		- 传统存储管理的特征、缺点
		- 局部性原理
		- 虚拟内存的定义和特征
		- 如何实现虚拟内存技术
	- 请求分页管理方式
		- 页表机制---请求页表与基本页表的区别
		- 缺页中断机构
		- 地址变换机构
	- 页框分配
	- 页面置换算法
		- 最佳置换算法---OPT
		- 先进先出置换算法---FIFO
		- 最近最久未使用置换算法---LRU
		- 时钟置换算法---CLOCK
		- 改造型时钟置换算法
	<!-- - 页面分配策略
		- 驻留集
		- 页面分配、置换策略
			- 固定分配局部置换
			- 可变分配局部置换
			- 可变分配全局置换
		- 何时调入页面？
		- 从何处调页？
		- 抖动（颠簸）现象
		- 工作集 -->
	- 内存映射文件
	- 虚拟存储器性能的影响因素和改进方法
---
# **文件**
- 文件
	- 文件的基本概念
	- 文件元数据和索引节点
	- 文件的操作
		- 建立
		- 删除
		- 打开
		- 关闭
		- 读写
	- 文件的保护
	- 文件的逻辑结构
	- 文件的物理结构
- 目录
	- 目录的基本概念
	- 树形目录
	- 目录的操作
	- 硬链接和软连接
- 文件系统
	- 文件系统的全局结构
		- 文件在外存
		- 文件在内存
	- 外存空闲空间管理办法
	- 虚拟文件系统
	- 文件系统挂载
# **IO**
- 管理基础
	- 设备
		- 设备的基础概念
		- 设备的分类
		- IO接口
		- IO端口
	- IO控制方式
		- 轮询
		- 中断
		- DMA
	- IO软件层次结构
		- 中断处理程序
		- 驱动程序
		- 设备独立软件
		- 用户层IO软件
	- 输入输出应用程序结构
		- 字符设备结构
		- 块设备结构
		- 网络设备接口
		- 阻塞、非阻塞IO
- 设备独立软件
	- 缓冲区管理
	- 设备分配与回收
	- 假脱机技术
	- 设备驱动程序接口
- 外存管理
	- 磁盘
		- 磁盘结构 格式化
		- 分区
		- 调度方法
	- 固态硬盘
		- 读写性能特性
		- 磨损均衡